# 인덱스 기본

<br>

## 인덱스 구조 및 탐색

<br>

### 인덱스 기본 이해

데이터베이스 테이블에서 데이터를 찾는 방법은 테이블 전체 스캔, 인덱스를 사용한 방법으로 나눠진다. 인덱스는 큰 테이블에서 소량 데이터를 검색할 때 사용되며 특히 OLTP에서 소량 데이터를 주로 검색하기 때문에 인덱스 튜닝이 매우 중요하다. 

<br>

**인덱스 튜닝의 핵심 요소**

- 인덱스 스캔 과정에서 발생하는 비효율을 줄이기
- 인덱스 스캔 후 테이블 레코드를 액세스할 때 발생하는 랜덤 액세스 최소화

<br>

인덱스 튜닝은 랜덤 I/O를 최소화 하기 위한 것이며 조인 메소드 중 가장 일반적으로 사용하는 NL 조인이 대량 데이터를 조인할 때 느린 경우도 랜덤 I/O 때문이다. 이 때문에 느린 랜덤 I/O를 극복하기 위해 Sort Merge, Hash이 개발되었다. 

<br>

### 인덱스 구조

DBMS는 일반적으로 B*Tree 인덱스를 사용한다. 

루트와 브랜치 블록에는 키 값을 갖지 않는 LMC(Leftmost Child) 레코드가 존재하며 자식 노ㅗ드 중 가장 왼쪽에 위치한 블록을 가리킨다.

<br>

리프 블록에 저장된 각 레코드는 키값 순으로 정렬돼 있을 뿐만 아니라테이블 레코드를 가리키는 주소값 즉, ROWID를 갖는다. 인덱스 키 값이 같을 경우 ROWID 순으로 정렬된다.

- ROWID = 데이터블록 주소 +로우 번호
- 데이터 블록 주소 = 데이터 파일 번호+블록 번호
- 블록 번호: 데이터파일 내에서 부여한 상대적 순번
- 로우 번호 : 블록 내 순번

<br>

인덱스 탐색 과정은 수직적 탁색과 수평적 탐색으로 나눌 수 있다.

- 수직적 탐색 : 인덱스 시작지점을 찾는 과정
- 수평적 탐색: 데이터를 찾는 과정

<br>

### 인덱스 수직적 탐색

인덱스 수직적 탐색이란 인덱스의 시작지점을 찾는 과정이며 탐색의 시작은 Root 블록에서 시작된다.  

- Root -> Branch -> Leaf

수직적 탐색에서 데이터를 찾는 과정은 Root 노드와 데이터 비교 후 Branch로 이동 이 때 Branch의 데이터와 찾고 있는 데이터가 일치하여도 해당 노드로 이동하는 것이 아닌 바로 직전 레코드가 가르키는 하위 노드로 이동한다.

<br>

### 인덱스 수평적 탐색

인덱스 수평적 탐색은 본격적으로 데이터를 탐색하는 과정이다.  인덱스 리프 노드는 양방향 연결 리스트 구조로 서로 앞뒤 블록에 대한 주소값을 갖는다. 인덱스를 수평 탐색 하는 이유는 첫째,조건절을 만족하는 데이터를 모두 찾기 위해서이고 둘째, ROWID를 얻기 위해서이다. 인덱스 스캔의 경우 필요한 컬럼을 인덱스가 모두 갖고 있어 인덱스만 스캔하고 끝나는 경우도 있지만 일반적으로 인덱스 스캔후 테이블 액세스도 수행된다. 이 때 ROWID가 필요하다.

<br>

### 결합 인덱스 구조와 탐색

일반적으로 인덱스가 (이름, 성별) 로 구성되어 있고 "홍길동, 남자" 라는 사원을 찾을 때 아래의 같은 쿼리를 작성할 경우

```sql
SELECT 사원, 성별 FROM 사원 WHERE 이름 = '홍길동' AND 성별 = '남자'
```

이름이 홍길동 인 사원을 찾고 이후에 성별이 남자인 사원을 찾는다고 알고 있지만 이는 잘못된 내용이다. 결합인덱스의 경우 (홍길동, 남자) 로 생성되기 때문에 (홍길동,남자) 로 검색하나 (남자,홍길동) 으로 검색하나 인덱스 I/O는 동일하다. 인덱스 구조가 성능에 영향을 미치기는 하지만 이러한 개념은 잘 못된 것임을 알아두자.



